var WalletLibTestContract = artifacts.require("WalletLibTestContract");
var DirectCrowdsaleTestContract = artifacts.require("DirectCrowdsaleTestContract");
var CrowdsaleToken = artifacts.require("CrowdsaleToken");

var WalletAddress;
//var TokenAddress;

contract('WalletLibTestContract', function(accounts) {
  it("should properly initialize wallet data", function() {
    var returnObj = {};
    var c;

    return WalletLibTestContract.deployed().then(function(instance) {
      c = instance;
      return c.maxOwners.call();
    }).then(function(mo){
      returnObj.mo = mo;
      return c.ownerCount.call();
    }).then(function(oc){
      returnObj.oc = oc;
      return c.requiredAdmin.call();
    }).then(function(ra){
      returnObj.ra = ra;
      return c.requiredMinor.call();
    }).then(function(rmi){
      returnObj.rmi = rmi;
      return c.requiredMajor.call();
    }).then(function(rma){
      returnObj.rma = rma;
      return c.owners.call();
    }).then(function(o){
      returnObj.o = o;
      console.log(returnObj.o);
      return c.majorThreshold.call(0);
    }).then(function(mt){
      returnObj.mt = mt;
      assert.equal(returnObj.mo.valueOf(), 50, "Max owners should be set to 50.");
      assert.equal(returnObj.oc.valueOf(), 5, "Owner count should reflect 5.");
      assert.equal(returnObj.ra.valueOf(), 4, "Required sigs for admin should reflect 4.");
      assert.equal(returnObj.rmi.valueOf(), 1, "Required sigs for minor tx should show 1.");
      assert.equal(returnObj.rma.valueOf(), 3, "Required sigs for major tx should show 3.");
      assert.equal(returnObj.mt.valueOf(), 100000000000000000000, "Max threshold should reflect 100 ether.");
    });
  });
});

contract('CrowdsaleToken', function(accounts) {
  it("should properly initialize token data", function() {
    var returnObj = {};
    var c;

    return CrowdsaleToken.deployed().then(function(instance) {
      c = instance;
      return c.name.call();
    }).then(function(n){
      returnObj.name = n;
      return c.symbol.call();
    }).then(function(s){
      returnObj.symbol = s;
      return c.decimals.call();
    }).then(function(d){
      returnObj.decimals = d;
      return c.totalSupply.call();
    }).then(function(ts){
      returnObj.totalSupply = ts;
      assert.equal(returnObj.name.valueOf(), 'Tester Token', "Name should be set to Tester Token.");
      assert.equal(returnObj.symbol.valueOf(), 'TST', "Symbol should be set to TST.");
      assert.equal(returnObj.decimals.valueOf(), 18, "Decimals should be set to 18.");
      assert.equal(returnObj.totalSupply.valueOf(), 1000000, "Total supply should reflect 10.");
    });
  });
});

contract('DirectCrowdsaleTestContract', function(accounts) {
  it("should initialize the direct crowdsale contract data", function() {
    var returnObj = {};
    var c;

    return DirectCrowdsaleTestContract.deployed().then(function(instance) {
      c = instance;
      return c.owner.call();
    }).then(function(o){
      WalletAddress = o.valueOf();
      console.log(WalletAddress);
      returnObj.owner = o;
      return c.tokenPrice.call();
    }).then(function(t){
      returnObj.tokenPrice = t;
      return c.capAmount.call();
    }).then(function(ca){
      returnObj.capAmount = ca;
      return c.minimumTargetRaise.call();
    }).then(function(tr){
      returnObj.minimumTargetRaise = tr;
      return c.auctionSupply.call();
    }).then(function(as){
      returnObj.auctionSupply = as;
      return c.startTime.call();
    }).then(function(st){
      returnObj.startTime = st;
      return c.endTime.call();
    }).then(function(et){
      returnObj.endTime = et;
      return c.addressCap.call();
    }).then(function(ac){
      returnObj.addressCap = ac;
      return c.ownerBalance.call();
    }).then(function(ob){
      returnObj.ownerBalance = ob;
      //assert.equal(returnObj.owner.valueOf(), "Owner should be set to the address of the wallet contract");
      assert.equal(returnObj.tokenPrice.valueOf(), 1000, "Token price should be 1000 tokens per ether");
      assert.equal(returnObj.capAmount.valueOf(), 1e+21, "capAmount should be set to 1000000000000000000000 wei");
      assert.equal(returnObj.minimumTargetRaise.valueOf(), 300000000000000000000, "Minimum sale target should be set to 300000000000000000000 wei");
      assert.equal(returnObj.auctionSupply.valueOf(), 800000, "Initial supply of tokens for the sale should reflect 800000.");
      assert.equal(returnObj.addressCap.valueOf(),50000000000000000000, "Cap of ether spent per address should be 50000000000000000000");
      assert.equal(returnObj.ownerBalance.valueOf(), 0, "Amount of wei raised in the crowdsale should be zero");
    });
  });
  it("should deny all requests to interact with the contract before the crowdsale starts", function() {
    var c;

    return DirectCrowdsaleTestContract.deployed().then(function(instance) {
     c = instance;
     //console.log(web3.eth.getBalance(accounts[1]));
     return c.withdrawTokens(103,{from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.logs[0].args.Msg, 'Token Sale has not ended yet!', "should give message that token sale has not ended");
      return c.withdrawEther({from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.logs[0].args.Msg, 'sender has no excess ether to withdraw!', "should give error message that the sender has no ether to witdraw");
      return c.receivePurchase(103,{value: 40000000000000000000, from: accounts[1]});
    }).then(function(ret) {
      console.log(accounts[5]);
      assert.equal(ret.logs[0].args.Msg, 'Invalid Purchase! Check send time and amount of ether.', "should give an error message since sale has not started");
      //assert.equal(ret,100000000000000000000000000, "Accounts[0] balance should still be at the Initial balance");
    //   return c.sendTransaction(103,{value: 100000000000000000000, from: accounts[5]});
    // }).then(function(ret) {
    //   assert.equal(ret.logs[0].args.Msg, 'Invalid Purchase! Check send time and amount of ether.', "should give an error message since sale has not started");
      //assert.equal(accounts[0].balance,100000000000000000000000000, "Accounts[0] balance should still be at the Initial balance");   // need to figure out how to check balance
      return c.changeAddressCap(100000000000000000000, 103, {from: accounts[5]});      // need to figure out how to send from the wallet address
    }).then(function(ret) {
      return c.addressCap.call();
    }).then(function(ret) {
      assert.equal(ret.valueOf(),100000000000000000000, "Cap of ether spent per address should have changed to 100000000000000000000");

    });
  });


    /********************************************************
    DURING SALE
    /*******************************************************/
  it("should deny invalid payments during the sale and accept payments up to the cap", function() {
    var c;

    return DirectCrowdsaleTestContract.deployed().then(function(instance) {
      c = instance;
      return c.withdrawTokens(106,{from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.logs[0].args.Msg, 'Token Sale has not ended yet!', "should give message that token sale has not ended");
      return c.withdrawEther({from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.logs[0].args.Msg, 'sender has no excess ether to withdraw!', "should give error message that the sender has no ether to witdraw");
      return c.receivePurchase(106,{from:accounts[0]});
    }).then(function(ret) {
       assert.equal(ret.logs[0].args.Msg, 'Invalid Purchase! Check send time and amount of ether.', "should give an error message since no ether was sent");
    //    return c.sendTransaction({value: 40000000000000000000, from:accounts[0]});
    // }).then(function(ret) {
      return c.receivePurchase(106,{value:40000000000000000000,from:accounts[0]});
    }).then(function(ret) {
      return c.getContribution.call(accounts[0], {from:accounts[0]});
    }).then(function(ret) {
       console.log(ret);
       assert.equal(ret.valueOf(),40000000000000000000, "accounts[0] amount of wei contributed should be 40000000000000000000 wei");
      return c.receivePurchase(106,{value: 40000000000000000000, from:accounts[0]});
    }).then(function(ret) {
      return c.getContribution.call(accounts[0], {from:accounts[0]});
    }).then(function(ret) {
      console.log(ret);
      assert.equal(ret.valueOf(),80000000000000000000, "accounts[0] amount of wei contributed should be 80000000000000000000 wei");
      return c.getTokenPurchase.call(accounts[0],{from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.valueOf(),80000, "accounts[0] amount of tokens purchased should be 80000 tokens");
      return c.receivePurchase(106, {value: 40000000000000000000, from:accounts[0]});
    }).then(function(ret) {
      return c.getContribution.call(accounts[0],{from:accounts[0]});
    }).then(function(ret) {
      console.log(ret);
      assert.equal(ret.valueOf(),100000000000000000000, "accounts[0] amount of wei contributed should be 100000000000000000000 wei");
      return c.getTokenPurchase.call(accounts[0],{from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.valueOf(),100000, "accounts[0] amount of tokens purchased should be 100000 tokens");
      return c.getExcessEther.call(accounts[0], {from:accounts[0]});
    }).then(function(ret) {
      assert.equal(ret.valueOf(),20000000000000000000, "accounts[0] excess Ether donated should be 20000000000000000000");
      //return 
    });
  });
// address0 withdraws his excess ether.  address0 balance should be 20+ than before. excessEther should be 0.
// address1 contributes 100 ether, exactly to the cap.  has contributed should be 100.  withdrawTokensMap should be 100000. excess Ether should be 0.
// address1 tries to contribute 10 ether. should throw. no excess or more tokens. contributed should still be 100.
// address2 contributes 110 Ether. has contributed should be 100 ether, tokens should be 100000. excess ether should be 10
// address3 contributes 40 ether, hascontributed should be 40 ether, tokens should be 40000
});
